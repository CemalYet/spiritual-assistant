# SpiritualAssistant — AI Context

ESP32-S3 Islamic prayer clock with TFT touch display, WiFi captive portal, and adhan audio playback.

## Hardware

| Component | Detail |
|---|---|
| MCU | ESP32-S3-DevKitC-1, 16MB Flash, 8MB PSRAM (QIO OPI) |
| Display | ILI9341 240×320 TFT, SPI (HSPI), LovyanGFX driver |
| Touch | XPT2046, CS=GPIO9 |
| Audio | MAX98357 I2S amplifier, BCLK=17, LRC=18, DOUT=21, SD=47 |
| TFT Pins | CS=10, RST=11, DC=12, MOSI=13, SCLK=14, MISO=15 |

**Build:** PlatformIO, `espressif32@6.10.0`, Arduino framework, C++17, LittleFS filesystem.

## Architecture

```
main.cpp (thin orchestrator)
  ├── BootManager::run()         — blocking boot sequence
  ├── PrayerEngine::init/tick()  — prayer times, adhan trigger
  ├── WifiManager::init/tick()   — WiFi lifecycle after boot
  ├── PortalHandler::open/tick() — runtime AP portal
  └── DisplayTicker::tick()      — time/status updates every minute
```

### State-Driven UI Pattern

Writers never touch UI directly. All updates flow through shared state:

```
AppStateHelper::setX()  →  g_state (dirty flags)  →  UiStateReader (50ms timer)  →  UiPage* widgets
```

- `g_state` is a global `AppState` struct with ETL strings (zero heap allocation).
- `DirtyFlag` is a uint16_t bitfield: `TIME`, `DATE`, `NEXT_PRAYER`, `PRAYER_TIMES`, `WIFI_STATUS`, `VOLUME`, `MUTED`, `NTP_SYNCED`, `ADHAN_AVAILABLE`, `STATUS_SCREEN`, `LOCATION`.
- `AppStateHelper::setX()` compares old vs new, marks dirty only on change.
- `UiStateReader::update()` checks dirty flags, calls `UiPage*` setters, clears flags.
- `UiStateReader::init()` creates an LVGL timer (50ms period). Called in `LvglDisplay::begin()`. Idempotent (checks null timer).

### UI Pages (LVGL 8.x)

| Page | Screen | Purpose |
|---|---|---|
| `UiPageHome` | Time, date, location, next prayer, status icons | Main display |
| `UiPagePrayer` | All 6 prayer times, active prayer highlighted | Swipe right |
| `UiPageSettings` | Volume slider, WiFi button, QR code | Swipe left |
| `UiPageStatus` | Full-screen messages during boot only | Boot overlay |

Pages use LVGL tabview. `showPrayerScreen()` creates all 3 tabs. Status page is separate (overlays via `lv_scr_load`).

### Status Screen Rule

**Boot only.** `UiPageStatus` is used exclusively during `BootManager::run()`. After boot completes, `AppStateHelper::clearStatusScreen()` returns to home. Runtime portal info shown via `WifiState::PORTAL` on Settings page widget (not full-screen).

## Module Details

### BootManager (`boot_manager.cpp`)

Blocking boot sequence. Uses mini event loop (`LvglDisplay::loop()` + `delay(10)`).

**Flow:**
1. Check location → if none, start portal for first-time setup
2. If still no location after portal, start SettingsServer and wait for browser config
3. Try WiFi connection (if not offline mode)
4. NTP sync (if WiFi connected)
5. If no clock + no WiFi → auto portal for time sync
6. `clearStatusScreen()` → done

`Network::connectWiFi()` has a side effect: auto-starts portal on failure. `tryConnectWiFi()` handles this by detecting `isPortalActive()` after failed connect and delegating to `runPortalBlocking()`.

Portal exit conditions (3): WiFi connected (`didPortalConnectWiFi`), settings saved (`needsRecalculation`), offline selected (`isOfflineModeRequested`).

### PrayerEngine (`prayer_engine.cpp`)

All prayer time logic. Called from `loop()` via `tick()`.

**State:** `DailyPrayers s_prayers`, `optional<PrayerType> s_nextPrayer`, `int s_nextPrayerSeconds`, `bool s_showingTomorrow`, `int s_lastDay`.

**tick() handles:**
1. Settings recalculation check (`needsRecalculation` flag)
2. Day transition (midnight → reload today's prayers)
3. Prayer time cache refresh (when `s_nextPrayerSeconds == -1`)
4. Adhan trigger (when `secondsUntil <= 0`)

**Adhan playback:** `playAudioFileBlocking("/azan.mp3", onAdhanLoop)` — blocks main loop. `onAdhanLoop` callback keeps LVGL alive, handles mute/volume changes, updates time display.

**Tomorrow logic:** After last prayer (Isha), loads tomorrow's times with `dayOffset=1`. Sets `s_showingTomorrow=true`. Skips adhan trigger if `s_showingTomorrow && now._seconds > s_nextPrayerSeconds` (prevents false trigger for tomorrow's Fajr).

**Prayer source priority:** Diyanet API cache → API fetch → offline Adhan library calculation.

### WifiManager (`wifi_manager.cpp`)

WiFi lifecycle after boot. Does NOT handle portal.

- **Auto-disconnect:** 5 min timeout (`WIFI_TIMEOUT_MS`), stops SettingsServer, disconnects WiFi.
- **Reconnect:** Async. `reconnect()` calls `WiFi.begin()` directly, polls in `tick()` with 15s timeout.
- **Failed state:** Shows `WifiState::FAILED` for 3s, then reverts to `DISCONNECTED`.
- **Drop detection:** Tracks `s_wasConnected`. If WiFi drops unexpectedly, stops server, updates UI.

### PortalHandler (`portal_handler.cpp`)

Runtime AP portal. Opened from Settings button when no WiFi/credentials.

**`open()`:** Clears flags, starts portal, sets `WifiState::PORTAL`.

**`tick()` exit conditions:**
1. WiFi connected → `syncTime()`, `WifiManager::init(true)`, `PrayerEngine::recalculate()`
2. Settings saved → stop portal, sync time if connected, `PrayerEngine::recalculate()`
3. Offline mode → stop portal, `PrayerEngine::recalculate()`

### DisplayTicker (`display_ticker.cpp`)

Calls `LvglDisplay::updateTime()` and `updateStatus()` once per minute change.

### main.cpp (Orchestrator)

**setup():**
1. `initHardware()` — Serial, LittleFS, audio init
2. `Network::init()`
3. `LvglDisplay::begin()` — starts UiStateReader timer
4. `SettingsManager::init()`
5. `BootManager::run()` — blocking
6. `LvglDisplay::showPrayerScreen()` — creates tab pages
7. `PrayerEngine::init()`
8. `WifiManager::init(didConnectWiFi)`
9. `UiPageSettings::setAdvancedCallback(onSettingsPressed)` — set ONCE
10. Volume init

**loop():** `LvglDisplay::loop()` → `PortalHandler::tick()` → `WifiManager::tick()` → `PrayerEngine::tick()` → `DisplayTicker::tick()` → `SettingsServer::handle()` → status log every 30s → `delay(5)`.

**onSettingsPressed():** WiFi connected → show QR. Has credentials → `WifiManager::reconnect()`. Otherwise → `PortalHandler::open()`.

## Key Services (Pre-existing)

### Network (`network.cpp`)

Low-level WiFi operations.

- `connectWiFi()`: 3 retries × 15s timeout, disables power save, saves credentials on success. **Side effect:** auto-starts portal on failure.
- `handlePortal()`: Polls `WiFiPortal::handle()`. On success: saves credentials, waits 5s for browser, stops portal, remounts LittleFS, sets `portalConnectedWiFi=true`.
- `syncTime()`: Configures NTP (3 servers), waits up to 30s for sync.
- Stores SSID/password internally (`currentSSID[33]`, `currentPassword[65]`).

### SettingsManager (`settings_manager.cpp`)

NVS-backed settings with in-memory cache. Uses ESP32 Preferences library.

- Prayer method (1-15, default 13=Diyanet)
- Volume (0-100%, hardware maps to 0-21)
- Per-prayer adhan enable/disable (Sunrise always false)
- Connection mode ("wifi" or "offline")
- Location (lat, lng, city name, Diyanet ilce ID)
- `flagRecalculation`: set by setters, polled by PrayerEngine and PortalHandler

### SettingsServer (`settings_server.cpp`)

HTTP server on port 80 (STA mode). Serves settings page from LittleFS (`/settings.html`, gzipped). REST API: GET/POST `/api/settings`, `/api/status`, `/api/wifi`, etc. Uses `WebServer` library.

### WiFiPortal (`wifi_portal.cpp`)

Captive portal in AP mode. SSID: `AdhanSettings`, password: `12345678`, IP: `192.168.4.1`. Serves `index.html` from LittleFS. DNS redirects all domains to portal IP. 10 min timeout.

### PrayerAPI (`prayer_api.cpp`)

Fetches 30-day prayer times from Diyanet API (`ezanvakti.emushaf.net`). Caches in memory. Falls back to offline calculation if API fails.

### PrayerCalculator (`prayer_calculator.cpp`)

Offline prayer time calculation using Adhan library. Supports 15 methods. Used as fallback when Diyanet API unavailable or method != Diyanet.

## Data Types

```cpp
enum PrayerType : uint8_t { Fajr=0, Sunrise=1, Dhuhr=2, Asr=3, Maghrib=4, Isha=5, COUNT=6 };
enum WifiState  : uint8_t { DISCONNECTED, CONNECTING, CONNECTED, FAILED, PORTAL };
enum StatusScreenType : uint8_t { NONE, CONNECTING, PORTAL, MESSAGE, ERROR };

struct PrayerTime { std::array<char,6> value{"--:--"}; int toMinutes(); int toSeconds(); };
class DailyPrayers { std::array<PrayerTime,6> _times; optional<PrayerType> findNext(int minutes); };
struct CurrentTime { std::array<char,6> _hhMM; int _minutes; int _seconds; static CurrentTime now(); };
```

## Config Constants (`config.h`)

| Constant | Value | Notes |
|---|---|---|
| `PRAYER_METHOD` | 13 | Diyanet (Turkey) |
| `TIMEZONE` | `"CET-1CEST,M3.5.0,M10.5.0/3"` | Belgium POSIX TZ |
| `DIYANET_API_BASE` | `"https://ezanvakti.emushaf.net"` | 30-day cache |
| `TEST_MODE` | false | Prayer comparison tests |
| `FORCE_AP_PORTAL` | false | Force AP on boot (debug) |
| `NTP_SERVER1` | `"pool.ntp.org"` | Primary NTP |

## Debug Flags

- `FORCE_AP_PORTAL`: Clears saved WiFi credentials on boot, forces portal. Set in `config.h`.
- `TEST_MODE`: Runs `TestMode::runPrayerTimeTests()` instead of normal operation.

## File System (LittleFS `/data/`)

| File | Purpose |
|---|---|
| `index.html` | Captive portal page (AP mode) |
| `settings.html` | Settings page (STA mode, gzipped) |
| `style.css` | Shared styles |
| `script.js` | Settings page JavaScript |
| `success.html` | Portal WiFi success page |
| `/azan.mp3` | Adhan audio file |

## Common Pitfalls

1. **Network::connectWiFi() auto-starts portal on failure.** BootManager handles this. Never call connectWiFi expecting a simple true/false — check `isPortalActive()` after failure.
2. **UiStateReader timer starts in LvglDisplay::begin()** before prayer pages exist. Status screen works because it uses separate LVGL objects. Home page fields are null-safe.
3. **playAudioFileBlocking blocks the main loop.** The `onAdhanLoop` callback must call `LvglDisplay::loop()` and `SettingsServer::handle()` to keep UI and HTTP alive during playback.
4. **needsRecalculation flag** is polled by both `PrayerEngine::tick()` and `PortalHandler::tick()`. PortalHandler runs first in loop order and clears the flag, then calls `PrayerEngine::recalculate()` directly. When portal is not active, PrayerEngine handles it in its own tick.
5. **ETL strings are fixed-size.** `etl::string<32>` means 32 chars max. Truncation is silent. No heap allocation.
6. **WiFi auto-disconnect after 5 min.** WifiManager stops SettingsServer and disconnects to save power. User must press Settings button to reconnect.
7. **Tomorrow's prayer times.** After Isha, PrayerEngine loads tomorrow with `dayOffset=1` and sets `showingTomorrow=true`. The adhan trigger skips if `showingTomorrow && now > prayerTime` to prevent false triggers.
